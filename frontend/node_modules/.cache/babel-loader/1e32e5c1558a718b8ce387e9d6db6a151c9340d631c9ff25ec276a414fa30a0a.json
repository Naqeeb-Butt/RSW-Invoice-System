{"ast":null,"code":"const {\n  getOwnPropertyNames,\n  getOwnPropertySymbols\n} = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst {\n  hasOwnProperty\n} = Object.prototype;\n/**\n * Combine two comparators into a single comparators.\n */\nfunction combineComparators(comparatorA, comparatorB) {\n  return function isEqual(a, b, state) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nfunction createIsCircular(areItemsEqual) {\n  return function isCircular(a, b, state) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n    const {\n      cache\n    } = state;\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n    cache.set(a, b);\n    cache.set(b, a);\n    const result = areItemsEqual(a, b, state);\n    cache.delete(a);\n    cache.delete(b);\n    return result;\n  };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */\nfunction getShortTag(value) {\n  return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nfunction getStrictProperties(object) {\n  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */\nconst hasOwn =\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nObject.hasOwn || ((object, property) => hasOwnProperty.call(object, property));\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nfunction sameValueZeroEqual(a, b) {\n  return a === b || !a && !b && a !== a && b !== b;\n}\nconst PREACT_VNODE = '__v';\nconst PREACT_OWNER = '__o';\nconst REACT_OWNER = '_owner';\nconst {\n  getOwnPropertyDescriptor,\n  keys\n} = Object;\n/**\n * Whether the array buffers are equal in value.\n */\nfunction areArrayBuffersEqual(a, b) {\n  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n/**\n * Whether the arrays are equal in value.\n */\nfunction areArraysEqual(a, b, state) {\n  let index = a.length;\n  if (b.length !== index) {\n    return false;\n  }\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Whether the dataviews are equal in value.\n */\nfunction areDataViewsEqual(a, b) {\n  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));\n}\n/**\n * Whether the dates passed are equal in value.\n */\nfunction areDatesEqual(a, b) {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */\nfunction areErrorsEqual(a, b) {\n  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */\nfunction areFunctionsEqual(a, b) {\n  return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */\nfunction areMapsEqual(a, b, state) {\n  const size = a.size;\n  if (size !== b.size) {\n    return false;\n  }\n  if (!size) {\n    return true;\n  }\n  const matchedIndices = new Array(size);\n  const aIterable = a.entries();\n  let aResult;\n  let bResult;\n  let index = 0;\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (aResult = aIterable.next()) {\n    if (aResult.done) {\n      break;\n    }\n    const bIterable = b.entries();\n    let hasMatch = false;\n    let matchIndex = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (bResult = bIterable.next()) {\n      if (bResult.done) {\n        break;\n      }\n      if (matchedIndices[matchIndex]) {\n        matchIndex++;\n        continue;\n      }\n      const aEntry = aResult.value;\n      const bEntry = bResult.value;\n      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n      matchIndex++;\n    }\n    if (!hasMatch) {\n      return false;\n    }\n    index++;\n  }\n  return true;\n}\n/**\n * Whether the numbers are equal in value.\n */\nconst areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */\nfunction areObjectsEqual(a, b, state) {\n  const properties = keys(a);\n  let index = properties.length;\n  if (keys(b).length !== index) {\n    return false;\n  }\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    if (!isPropertyEqual(a, b, state, properties[index])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nfunction areObjectsEqualStrict(a, b, state) {\n  const properties = getStrictProperties(a);\n  let index = properties.length;\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n  let property;\n  let descriptorA;\n  let descriptorB;\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index];\n    if (!isPropertyEqual(a, b, state, property)) {\n      return false;\n    }\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nfunction arePrimitiveWrappersEqual(a, b) {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */\nfunction areRegExpsEqual(a, b) {\n  return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */\nfunction areSetsEqual(a, b, state) {\n  const size = a.size;\n  if (size !== b.size) {\n    return false;\n  }\n  if (!size) {\n    return true;\n  }\n  const matchedIndices = new Array(size);\n  const aIterable = a.values();\n  let aResult;\n  let bResult;\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (aResult = aIterable.next()) {\n    if (aResult.done) {\n      break;\n    }\n    const bIterable = b.values();\n    let hasMatch = false;\n    let matchIndex = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (bResult = bIterable.next()) {\n      if (bResult.done) {\n        break;\n      }\n      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n      matchIndex++;\n    }\n    if (!hasMatch) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */\nfunction areTypedArraysEqual(a, b) {\n  let index = a.byteLength;\n  if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n    return false;\n  }\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */\nfunction areUrlsEqual(a, b) {\n  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;\n}\nfunction isPropertyEqual(a, b, state, property) {\n  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {\n    return true;\n  }\n  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\nconst ARRAY_BUFFER_TAG = '[object ArrayBuffer]';\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATA_VIEW_TAG = '[object DataView]';\nconst DATE_TAG = '[object Date]';\nconst ERROR_TAG = '[object Error]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\nconst TYPED_ARRAY_TAGS = {\n  '[object Int8Array]': true,\n  '[object Uint8Array]': true,\n  '[object Uint8ClampedArray]': true,\n  '[object Int16Array]': true,\n  '[object Uint16Array]': true,\n  '[object Int32Array]': true,\n  '[object Uint32Array]': true,\n  '[object Float16Array]': true,\n  '[object Float32Array]': true,\n  '[object Float64Array]': true,\n  '[object BigInt64Array]': true,\n  '[object BigUint64Array]': true\n};\nconst URL_TAG = '[object URL]';\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nfunction createEqualityComparator(_ref) {\n  let {\n    areArrayBuffersEqual,\n    areArraysEqual,\n    areDataViewsEqual,\n    areDatesEqual,\n    areErrorsEqual,\n    areFunctionsEqual,\n    areMapsEqual,\n    areNumbersEqual,\n    areObjectsEqual,\n    arePrimitiveWrappersEqual,\n    areRegExpsEqual,\n    areSetsEqual,\n    areTypedArraysEqual,\n    areUrlsEqual,\n    unknownTagComparators\n  } = _ref;\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a, b, state) {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n    // If either of the items are nullish and fail the strictly equal check\n    // above, then they must be unequal.\n    if (a == null || b == null) {\n      return false;\n    }\n    const type = typeof a;\n    if (type !== typeof b) {\n      return false;\n    }\n    if (type !== 'object') {\n      if (type === 'number') {\n        return areNumbersEqual(a, b, state);\n      }\n      if (type === 'function') {\n        return areFunctionsEqual(a, b, state);\n      }\n      // If a primitive value that is not strictly equal, it must be unequal.\n      return false;\n    }\n    const constructor = a.constructor;\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (Array.isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = toString.call(a);\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n    // For RegExp, the properties are not enumerable, and therefore will give false positives if\n    // tested like a standard object.\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n    }\n    // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === URL_TAG) {\n      return areUrlsEqual(a, b, state);\n    }\n    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === ERROR_TAG) {\n      return areErrorsEqual(a, b, state);\n    }\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n    if (TYPED_ARRAY_TAGS[tag]) {\n      return areTypedArraysEqual(a, b, state);\n    }\n    if (tag === ARRAY_BUFFER_TAG) {\n      return areArrayBuffersEqual(a, b, state);\n    }\n    if (tag === DATA_VIEW_TAG) {\n      return areDataViewsEqual(a, b, state);\n    }\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n    if (unknownTagComparators) {\n      let unknownTagComparator = unknownTagComparators[tag];\n      if (!unknownTagComparator) {\n        const shortTag = getShortTag(a);\n        if (shortTag) {\n          unknownTagComparator = unknownTagComparators[shortTag];\n        }\n      }\n      // If the custom config has an unknown tag comparator that matches the captured tag or the\n      // @@toStringTag, it is the source of truth for whether the values are equal.\n      if (unknownTagComparator) {\n        return unknownTagComparator(a, b, state);\n      }\n    }\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n/**\n * Create the configuration object used for building comparators.\n */\nfunction createEqualityComparatorConfig(_ref2) {\n  let {\n    circular,\n    createCustomConfig,\n    strict\n  } = _ref2;\n  let config = {\n    areArrayBuffersEqual,\n    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n    areDataViewsEqual,\n    areDatesEqual: areDatesEqual,\n    areErrorsEqual: areErrorsEqual,\n    areFunctionsEqual: areFunctionsEqual,\n    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n    areNumbersEqual: areNumbersEqual,\n    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n    areRegExpsEqual: areRegExpsEqual,\n    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,\n    areUrlsEqual: areUrlsEqual,\n    unknownTagComparators: undefined\n  };\n  if (createCustomConfig) {\n    config = Object.assign({}, config, createCustomConfig(config));\n  }\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n    config = Object.assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual\n    });\n  }\n  return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nfunction createInternalEqualityComparator(compare) {\n  return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n    return compare(a, b, state);\n  };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nfunction createIsEqual(_ref3) {\n  let {\n    circular,\n    comparator,\n    createState,\n    equals,\n    strict\n  } = _ref3;\n  if (createState) {\n    return function isEqual(a, b) {\n      const {\n        cache = circular ? new WeakMap() : undefined,\n        meta\n      } = createState();\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict\n      });\n    };\n  }\n  if (circular) {\n    return function isEqual(a, b) {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined,\n        strict\n      });\n    };\n  }\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict\n  };\n  return function isEqual(a, b) {\n    return comparator(a, b, state);\n  };\n}\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nconst deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nconst strictDeepEqual = createCustomEqual({\n  strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nconst circularDeepEqual = createCustomEqual({\n  circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nconst strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nconst shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nconst strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nconst circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nconst strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nfunction createCustomEqual() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false\n  } = options;\n  const config = createEqualityComparatorConfig(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n  return createIsEqual({\n    circular,\n    comparator,\n    createState,\n    equals,\n    strict\n  });\n}\nexport { circularDeepEqual, circularShallowEqual, createCustomEqual, deepEqual, sameValueZeroEqual, shallowEqual, strictCircularDeepEqual, strictCircularShallowEqual, strictDeepEqual, strictShallowEqual };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}